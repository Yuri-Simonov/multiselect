Друзья, всем привет!
В данном видео я покажу вариант создания кастомного мультиселектора, где также можно будет вводить в инпут текст и в зависимости от него будут фильтроваться доступные значения. Также выбор значения можно будет отменять как при повторном нажатии на уже выбранное значение, так и при клике на него в поле ввода. Значения также можно будет как выбирать и переключать с помощью клавиатуры, так и удалять с ее помощью. 
Если интересно как это делается, смотрите видео до конца.

Как обычно, разметка и стили уже подготовлены заранее, чтобы не тратить на это время.
Я лишь вкратце поясню их. У нас будет условное поле ввода, где будут храниться выбранные элементы и будет инпут для набора текста. А также будет список с доступными вариантами.

Что касается стилей, то тут небольшой файл для обнуления и общая визуализация элементов. В целом тут нет ничего такого необычного, поэтому при желании можете подробно самостоятельно посмотреть. Весь код будет доступен по ссылке под видео.

========================

Для начала давайте найдем все необходимые элементы разметки, которые нам в дальнейшем понадобятся, а именно:
- условное поле ввода (это multiselect__content) - белый прямоугольник
- родителя выбранных значений из списка (multiselect__choised)
- сами выбранные элементы (multiselect__choised-item)
- родителя с доступными значениями (multiselect__dropdown)
- и сами доступные значения (multiselect__dropdown-item)

Теперь, когда мы имеем доступ ко всем элементам разметки, можно начинать добавлять им логику.

Давайте реализуем открытие и закрытие выпадающего списка.

И сразу же реализуем закрытие списка при клике вне элементов мультиселектора.

Открытие и закрытие сделано.
Теперь реализуем добавление значений из выбранного списка. Суть будет следующая: при клике на элемент, мы будем создавать тег "li", в который будем помещать текстовое значение выбранного элемента.
Давайте для этого создадим функцию "createNewElement"... (без функции checkInputValue)

Дальше надо обработать отмену выбранного значения в выпадающем списке. Для этого создадим функцию "searchChoisedElement"... (без функции deleteElement внутри).
И в обработчике клика "dropdownList" нужно добавить условие, в зависимости от которого будет создаваться новый элемент или будет сниматься выделение.
И задание инпуту фокуса нужно вынести из условия, чтобы он срабатывал каждый раз, независимо от того, создаем мы элемент или снимаем выделение.

Дальше надо обработать удаление выбранного элемента из поля. Для этого создадим функцию "deleteElement"...

Осталось тебе объединить написанные функции,то есть, сделать так, чтобы независимо от того, где был произведен клик по выбранному элементу, это так же отображалось и во втором месте.
Сделать это довольно-таки просто. Мы повесим обработчик на элементы в поле ввода, которые будут вызывать функцию "searchChoisedElement", она будет убирать выделение в выпадающем списке у выбранного элемента. И так же эта функция будет вызывать функцию "deleteElement", которая удалить из поля ввода элемент.
Давайте это реализуем.

Еще нужно сделать лишь поиск элементов в выпадающем списке, которые подходят под введеный текст в инпут.
Давайте для реализации этого создадим функцию "checkInputValue"...

Функция готова. Ее мы будем вызывать в 2 двух случаях:
- когда происходит изменение значения в инпуте
- и когда мы выбираем какой-то элемент из списка.

Для первого случая нам надо повесить обработчик события на инпут...
Здесь также стоит предусмотреть такой вариант, что на инпут могут попасть не по клику на него, а табом и тогда список не раскроется. Давайте этот момент тоже пофиксим.

И для второго случая, когда мы выбираем какой-то элемент, надо не просто сбрасывать значение в инпуте, а снова вызывать функцию проверки на совпадение, чтобы список корректно отобразился.
Добавим вызов функции "checkInputValue" после создания элемента.

/////////////////////////////

Основной функционал работает, но для полной красоты давайте еще реализуем события клавиатуры, чтобы максимально удобным наш мультиселектор.

Для реализации событий клавиш нам понадобится инпут, на него мы и будем вешать все события. Почему именно на него, сейчас поймете.
Нам нужно отслеживать клавишу "вниз", "вверх" и "enter".

Также нам понадобится счетчик, с помощью которого мы будем говорить браузеру, какой из элементов сейчас надо показать активным.
И для него же сразу сделаем функцию, которая будет следить за тем, чтобы мы не выходили за пределы списка, а переключать с первого на последний при нажатии клавиши "вверх" и аналогично наоборот, когда переходим с последнего элемента на первый при нажатии клавиши "вниз". (checkCurrentCounter)

Когда мы будем переключаться между элементами, у них будет меняться модификатор класса. И чтобы он корректно каждый раз добавлялся к новому элементу, мы будем пробегаться по списку и убирать у всех активный класс, чтобы не было несколько активных элементов. Напишем для этого еще одну функцию (resetActiveClass)

Теперь можно доделать логику для клавиш "вверх" и "вниз". А также объединить их, т.к. у них отличается лишь поведение счетчика.

Теперь у нас работают события клавиши, но если мы наведем мышкой на список, то у нас получаются сразу 2 активных элемента. Так быть не должно. Поэтому давайте на список повесим событие мыши уже.
Данное событие будет вызывать еще одну функцию, которая будет сбрасывать счетчик и активный класс в первоначальное состояния. (resetToInitialState).

Давайте вернемся к событию клавиши "enter" и доделаем его, чтобы элементы выбирались.
В момент нажатия клавиши "enter" мы будем искать текущий активный элемент и имитировать клик мышки по нему, т.к. событие клика у нас уже реализовано.

Теперь нам осталось лишь доработать функционал удаления выбранных элементов с помощью клавиши "Backspace".
Для этого повесим на инпут еще одно событие клавиши. И в момент нажатия клавиши "Backspace" мы будем проверять, что курсор в инпуте стоит в начале, нажата нужная нам клавиша и в поле присутствует хотя бы 1 элемент из списка.
Если все три условия выполняются, имитируем клик по этому элементу.

/////////////////////////////

Осталось проверить теперь полностью работоспособность мультиселекта. (вставка слов тоже работает)

Что ж, теперь, если я ничего не упустил, то это все, что я хотел вам показать в данном видео. Надеюсь, видео будет кому-то полезным.

До встречи в следующих видео, пока.