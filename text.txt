Друзья, всем привет!
В данном видео я покажу вариант создания кастомного мультиселектора, с которым можно взаимодействовать как с помощью мышки, так и клавиатуры. Под взаимодействием в данном случае понимается выбор элементов из списка, а также отмена выбора тремя различными способами:
- повторный клик в списке;
- клик по элементу в самом поле;
- и с помощью клавишы удаления "Backspace".

Если интересно как это делается, смотрите видео до конца.

Как обычно, разметка и стили уже подготовлены заранее, чтобы не тратить на это время.
Я лишь вкратце поясню их. 
Так как мы будем делать мультиселект и слово довольно-таки длинное, поэтому для удобства во всем коде я его сократил до двух букв - "ms".

По разметке у нас будет условное поле ввода, где будут храниться выбранные элементы и будет инпут для набора текста. А также будет список с доступными вариантами.

Что касается стилей, то тут небольшой файл для обнуления и общая визуализация элементов. В целом тут нет ничего такого необычного, поэтому при желании можете подробно самостоятельно посмотреть. Весь код будет доступен по ссылке под видео.

========================

Для начала давайте найдем все необходимые элементы разметки, которые нам в дальнейшем понадобятся, а именно:
- родителя с доступными значениями (ms__dropdown)
- сами доступные значения (ms__dropdown-item)
- инпут, куда будет вводиться текст (ms__input)
- и родителя выбранных значений из списка (ms__chose)

Теперь, когда мы имеем доступ ко всем элементам разметки, можно начинать добавлять им логику.

Давайте реализуем открытие и закрытие выпадающего списка.

И сразу же реализуем закрытие списка при клике вне элементов мультиселектора.

Здесь также стоит предусмотреть такой вариант, что на инпут могут попасть не по клику на него, а табом и тогда список не раскроется. Давайте этот момент тоже пофиксим.

Открытие и закрытие сделано.
Теперь реализуем добавление значений из выбранного списка. Суть будет следующая: при клике на элемент, мы будем создавать тег "li", в который будем помещать текстовое значение выбранного элемента.
Давайте для этого создадим функцию "createNewElement"... (без функции checkInputValue)

Дальше надо обработать отмену выбранного значения в выпадающем списке. Для этого создадим функцию "searchChoseElement"... (без функции deleteElement внутри).
И в обработчике клика "dropdownList" нужно добавить условие, в зависимости от которого будет создаваться новый элемент или будет сниматься выделение.
И задание инпуту фокуса нужно вынести из условия, чтобы он срабатывал каждый раз, независимо от того, создаем мы элемент или снимаем выделение.

Дальше надо обработать удаление выбранного элемента из поля. Для этого создадим функцию "deleteElement"...

Осталось теперь объединить написанные функции, то есть, сделать так, чтобы независимо от того, где был произведен клик по выбранному элементу, это так же отображалось и во втором месте.
Сделать это довольно-таки просто. Мы повесим обработчик на элементы в поле ввода, которые будут вызывать функцию "searchChoseElement", она будет убирать выделение в выпадающем списке у выбранного элемента. И так же эта функция будет вызывать функцию удаления "deleteElement", которая в свою очередь удалит из поля ввода соответствующий элемент.
Давайте это реализуем.

Еще нужно сделать поиск элементов в выпадающем списке, которые подходят под введеный текст в инпут.
Для этого нам нужно повесить обработчик на ввод текста в инпуте...
...и создать функцию, которая будет проверять на совпадения с элементами списка ("checkInputValue")

Функция готова. Ее мы будем вызывать в 2 двух случаях:
- когда происходит изменение значения в инпуте
- и когда мы выбираем какой-то элемент из списка, потому что при выборе элемента мы сделали так, что значение текста сбрасывается, следовательно, мы опять возвращаемся в первому случаю, то есть, к изменению значения в инпуте.

И для второго случая, когда мы выбираем какой-то элемент, надо не просто сбрасывать значение в инпуте, а снова вызывать функцию проверки на совпадение, чтобы список корректно отобразился.
Добавим вызов функции "checkInputValue" после создания элемента.

/////////////////////////////

Основной функционал работает, но для полной красоты давайте еще реализуем события клавиатуры, чтобы сделать максимально удобным наш мультиселектор.

Для реализации событий клавиш нам понадобится инпут, на него мы и будем вешать все события. Почему именно на него, сейчас поймете.
Нам нужно отслеживать клавишу "вниз", "вверх" и "enter".

Также нам понадобится счетчик, с помощью которого мы будем говорить браузеру, какой из элементов сейчас надо показать активным.
И для него же сразу сделаем функцию, которая будет следить за тем, чтобы мы не выходили за пределы списка, а переключать с первого на последний при нажатии клавиши "вверх" и аналогично наоборот, когда переходим с последнего элемента на первый при нажатии клавиши "вниз". (checkCurrentCounter)

Когда мы будем переключаться между элементами, у них будет меняться модификатор класса. И чтобы он корректно каждый раз добавлялся к новому элементу, мы будем пробегаться по списку и убирать у всех активный класс, чтобы не было несколько активных элементов. Напишем для этого еще одну функцию (resetActiveClass)

Теперь можно доделать логику для клавиш "вверх" и "вниз". А также объединить их, т.к. у них отличается лишь поведение счетчика.

Теперь у нас работают события клавиши, но если мы наведем мышкой на список, то у нас получаются сразу 2 активных элемента. Так быть не должно. Поэтому давайте на список повесим событие мыши уже.
Данное событие будет вызывать еще одну функцию, которая будет сбрасывать счетчик и активный класс в первоначальное состояния. (resetToInitialState).

Давайте вернемся к событию клавиши "enter" и доделаем его, чтобы элементы выбирались.
В момент нажатия клавиши "enter" мы будем искать текущий активный элемент и имитировать клик мышки по нему, т.к. событие клика у нас уже реализовано.

Теперь нам осталось лишь доработать функционал удаления выбранных элементов с помощью клавиши "Backspace".
Для этого повесим на инпут еще одно событие клавиши. И в момент нажатия клавиши "Backspace" мы будем проверять, что курсор в инпуте стоит в начале, нажата нужная нам клавиша и в поле присутствует хотя бы 1 элемент из списка.
Если все три условия выполняются, имитируем клик по этому элементу.

/////////////////////////////

Давайте теперь немного отрефакторим наш код, потому что есть одни и те же обработчики событий, которые стоит объединить в одном месте. (msInput - keydown, document - click)

Осталось проверить теперь полностью работоспособность мультиселекта. (вставка слов тоже работает)

Что ж, теперь, если я ничего не упустил, то это все, что я хотел вам показать в данном видео. Надеюсь, видео будет кому-то полезным.

До встречи в следующих видео, пока.